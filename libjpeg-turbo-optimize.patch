diff --git a/simd/jsimd.h b/simd/jsimd.h
index a28754a..387ebaa 100644
--- a/simd/jsimd.h
+++ b/simd/jsimd.h
@@ -100,34 +100,34 @@ EXTERN(void) jsimd_extxrgb_ycc_convert_avx2
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
-EXTERN(void) jsimd_rgb_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_rgb_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extrgb_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extrgb_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extrgbx_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extrgbx_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extbgr_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extbgr_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extbgrx_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extbgrx_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extxbgr_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extxbgr_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extxrgb_ycc_convert_neon
+HIDE(EXTERN)(void) jsimd_extxrgb_ycc_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
 #ifndef NEON_INTRINSICS
 
-EXTERN(void) jsimd_extrgb_ycc_convert_neon_slowld3
+HIDE(EXTERN)(void) jsimd_extrgb_ycc_convert_neon_slowld3
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extbgr_ycc_convert_neon_slowld3
+HIDE(EXTERN)(void) jsimd_extbgr_ycc_convert_neon_slowld3
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
@@ -268,25 +268,25 @@ EXTERN(void) jsimd_extxrgb_gray_convert_avx2
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
-EXTERN(void) jsimd_rgb_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_rgb_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extrgb_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extrgb_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extrgbx_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extrgbx_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extbgr_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extbgr_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extbgrx_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extbgrx_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extxbgr_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extxbgr_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
-EXTERN(void) jsimd_extxrgb_gray_convert_neon
+HIDE(EXTERN)(void) jsimd_extxrgb_gray_convert_neon
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
@@ -425,37 +425,37 @@ EXTERN(void) jsimd_ycc_extxrgb_convert_avx2
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
 
-EXTERN(void) jsimd_ycc_rgb_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_rgb_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extrgb_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extrgb_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extrgbx_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extrgbx_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extbgr_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extbgr_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extbgrx_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extbgrx_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extxbgr_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extxbgr_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extxrgb_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_extxrgb_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_rgb565_convert_neon
+HIDE(EXTERN)(void) jsimd_ycc_rgb565_convert_neon
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
 
 #ifndef NEON_INTRINSICS
 
-EXTERN(void) jsimd_ycc_extrgb_convert_neon_slowst3
+HIDE(EXTERN)(void) jsimd_ycc_extrgb_convert_neon_slowst3
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
-EXTERN(void) jsimd_ycc_extbgr_convert_neon_slowst3
+HIDE(EXTERN)(void) jsimd_ycc_extbgr_convert_neon_slowst3
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
 
@@ -545,7 +545,7 @@ EXTERN(void) jsimd_h2v1_downsample_avx2
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
-EXTERN(void) jsimd_h2v1_downsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_downsample_neon
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
@@ -570,7 +570,7 @@ EXTERN(void) jsimd_h2v2_downsample_avx2
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
-EXTERN(void) jsimd_h2v2_downsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_downsample_neon
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
@@ -615,10 +615,10 @@ EXTERN(void) jsimd_h2v2_upsample_avx2
   (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
-EXTERN(void) jsimd_h2v1_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_upsample_neon
   (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
-EXTERN(void) jsimd_h2v2_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_upsample_neon
   (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
@@ -665,13 +665,13 @@ EXTERN(void) jsimd_h2v2_fancy_upsample_avx2
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
-EXTERN(void) jsimd_h2v1_fancy_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_fancy_upsample_neon
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
-EXTERN(void) jsimd_h2v2_fancy_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_fancy_upsample_neon
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
-EXTERN(void) jsimd_h1v2_fancy_upsample_neon
+HIDE(EXTERN)(void) jsimd_h1v2_fancy_upsample_neon
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
@@ -831,47 +831,47 @@ EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_avx2
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
 
-EXTERN(void) jsimd_h2v1_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extrgb_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extrgb_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extrgbx_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extrgbx_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extbgr_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extbgr_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extbgrx_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extbgrx_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extxbgr_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extxbgr_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v1_extxrgb_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v1_extxrgb_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
 
-EXTERN(void) jsimd_h2v2_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extrgb_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extrgb_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extrgbx_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extrgbx_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extbgr_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extbgr_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extbgrx_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extbgrx_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extxbgr_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extxbgr_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
-EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_neon
+HIDE(EXTERN)(void) jsimd_h2v2_extxrgb_merged_upsample_neon
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
 
@@ -1017,7 +1017,7 @@ EXTERN(void) jsimd_convsamp_sse2
 EXTERN(void) jsimd_convsamp_avx2
   (JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace);
 
-EXTERN(void) jsimd_convsamp_neon
+HIDE(EXTERN)(void) jsimd_convsamp_neon
   (JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace);
 
 EXTERN(void) jsimd_convsamp_dspr2
@@ -1048,7 +1048,7 @@ EXTERN(void) jsimd_fdct_islow_sse2(DCTELEM *data);
 extern const int jconst_fdct_islow_avx2[];
 EXTERN(void) jsimd_fdct_islow_avx2(DCTELEM *data);
 
-EXTERN(void) jsimd_fdct_islow_neon(DCTELEM *data);
+HIDE(EXTERN)(void) jsimd_fdct_islow_neon(DCTELEM *data);
 
 EXTERN(void) jsimd_fdct_islow_dspr2(DCTELEM *data);
 
@@ -1062,7 +1062,7 @@ EXTERN(void) jsimd_fdct_ifast_mmx(DCTELEM *data);
 extern const int jconst_fdct_ifast_sse2[];
 EXTERN(void) jsimd_fdct_ifast_sse2(DCTELEM *data);
 
-EXTERN(void) jsimd_fdct_ifast_neon(DCTELEM *data);
+HIDE(EXTERN)(void) jsimd_fdct_ifast_neon(DCTELEM *data);
 
 EXTERN(void) jsimd_fdct_ifast_dspr2(DCTELEM *data);
 
@@ -1086,7 +1086,7 @@ EXTERN(void) jsimd_quantize_sse2
 EXTERN(void) jsimd_quantize_avx2
   (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
 
-EXTERN(void) jsimd_quantize_neon
+HIDE(EXTERN)(void) jsimd_quantize_neon
   (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
 
 EXTERN(void) jsimd_quantize_dspr2
@@ -1127,10 +1127,10 @@ EXTERN(void) jsimd_idct_4x4_sse2
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
-EXTERN(void) jsimd_idct_2x2_neon
+HIDE(EXTERN)(void) jsimd_idct_2x2_neon
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
-EXTERN(void) jsimd_idct_4x4_neon
+HIDE(EXTERN)(void) jsimd_idct_4x4_neon
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
@@ -1163,7 +1163,7 @@ EXTERN(void) jsimd_idct_islow_avx2
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
-EXTERN(void) jsimd_idct_islow_neon
+HIDE(EXTERN)(void) jsimd_idct_islow_neon
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
@@ -1188,7 +1188,7 @@ EXTERN(void) jsimd_idct_ifast_sse2
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
-EXTERN(void) jsimd_idct_ifast_neon
+HIDE(EXTERN)(void) jsimd_idct_ifast_neon
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
@@ -1228,13 +1228,13 @@ EXTERN(JOCTET *) jsimd_huff_encode_one_block_sse2
   (void *state, JOCTET *buffer, JCOEFPTR block, int last_dc_val,
    c_derived_tbl *dctbl, c_derived_tbl *actbl);
 
-EXTERN(JOCTET *) jsimd_huff_encode_one_block_neon
+HIDE(EXTERN)(JOCTET *) jsimd_huff_encode_one_block_neon
   (void *state, JOCTET *buffer, JCOEFPTR block, int last_dc_val,
    c_derived_tbl *dctbl, c_derived_tbl *actbl);
 
 #ifndef NEON_INTRINSICS
 
-EXTERN(JOCTET *) jsimd_huff_encode_one_block_neon_slowtbl
+HIDE(EXTERN)(JOCTET *) jsimd_huff_encode_one_block_neon_slowtbl
   (void *state, JOCTET *buffer, JCOEFPTR block, int last_dc_val,
    c_derived_tbl *dctbl, c_derived_tbl *actbl);
 
@@ -1245,7 +1245,7 @@ EXTERN(void) jsimd_encode_mcu_AC_first_prepare_sse2
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
    UJCOEF *values, size_t *zerobits);
 
-EXTERN(void) jsimd_encode_mcu_AC_first_prepare_neon
+HIDE(EXTERN)(void) jsimd_encode_mcu_AC_first_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
    UJCOEF *values, size_t *zerobits);
 
@@ -1253,6 +1253,6 @@ EXTERN(int) jsimd_encode_mcu_AC_refine_prepare_sse2
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
    UJCOEF *absvalues, size_t *bits);
 
-EXTERN(int) jsimd_encode_mcu_AC_refine_prepare_neon
+HIDE(EXTERN)(int) jsimd_encode_mcu_AC_refine_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
    UJCOEF *absvalues, size_t *bits);
diff --git a/src/jchuff.h b/src/jchuff.h
index 21f17b8..6388ca1 100644
--- a/src/jchuff.h
+++ b/src/jchuff.h
@@ -36,9 +36,9 @@ typedef struct {
 } c_derived_tbl;
 
 /* Expand a Huffman table definition into the derived format */
-EXTERN(void) jpeg_make_c_derived_tbl(j_compress_ptr cinfo, boolean isDC,
+HIDE(EXTERN)(void) jpeg_make_c_derived_tbl(j_compress_ptr cinfo, boolean isDC,
                                      int tblno, c_derived_tbl **pdtbl);
 
 /* Generate an optimal table definition given the specified counts */
-EXTERN(void) jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl,
+HIDE(EXTERN)(void) jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl,
                                     long freq[]);
diff --git a/src/jcparam.c b/src/jcparam.c
index d74623c..80ee5e5 100644
--- a/src/jcparam.c
+++ b/src/jcparam.c
@@ -72,6 +72,28 @@ jpeg_add_quant_table(j_compress_ptr cinfo, int which_tbl,
  * The spec says that the values given produce "good" quality, and
  * when divided by 2, "very good" quality.
  */
+#ifdef SK_ENABLE_HI_JPEG
+static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
+  15,  15,  18,  22,  15,  46,  96,  46,
+  12,  20,  22,  28,  31,  46,  43,  76,
+   7,  22,  33,  32,  68,  65,  91, 121,
+  22,  22,  28,  61,  38,  43, 137,  65,
+  29,  22,  22,  65,  65,  68, 134,  99,
+  84,  38,  53, 103,  84,  73, 134, 156,
+  73,  68, 106,  61, 111, 152, 181, 139,
+  61, 127, 111, 149, 129, 187, 111, 180
+};
+static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
+  15,  15,  46,  38,  57,  38, 121, 141,
+  22,  15,  76,  53,  68,  81, 114, 121,
+  15, 103,  61, 114,  76, 127, 118, 111,
+  99,  43,  68, 137,  91, 137,  96, 118,
+  53,  38,  57,  73, 127, 114, 182, 190,
+  61,  96,  76,  99,  76, 134, 149, 174,
+ 141, 134,  88, 114, 137, 121, 174,   4,
+  84,  99,  73, 129, 170, 167, 156, 182
+};
+#else
 static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
   16,  11,  10,  16,  24,  40,  51,  61,
   12,  12,  14,  19,  26,  58,  60,  55,
@@ -92,6 +114,7 @@ static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
   99,  99,  99,  99,  99,  99,  99,  99,
   99,  99,  99,  99,  99,  99,  99,  99
 };
+#endif
 
 
 #if JPEG_LIB_VERSION >= 70
diff --git a/src/jdhuff.h b/src/jdhuff.h
index 3eee002..af3d3a6 100644
--- a/src/jdhuff.h
+++ b/src/jdhuff.h
@@ -19,10 +19,55 @@
 
 #include "jconfigint.h"
 
-
+#ifndef HUFF_DECODE_OPT
+#define HUFF_LOOKAHEAD  8
+#define HUFF_CODE_LARGE_LONG_ALIGNED 0
+#else
+// OH ISSUE: jpeg optimize
 /* Derived data constructed for each Huffman table */
-
-#define HUFF_LOOKAHEAD  8       /* # of bits of lookahead */
+#define MAX_HUFF_CODE_LEN 16
+
+#define HUFF_LOOKAHEAD  10      /* # of bits of lookahead  9-13 maybe */
+#define HUFF_AC_SYMBOLS 192
+
+#define HUFF_L_REM (16 - HUFF_LOOKAHEAD)
+#define HUFF_L_DUP ((1 << HUFF_L_REM) - (HUFF_L_REM + 1))
+#define HUFF_L_UNUSED ((1 << HUFF_L_REM) - (1 << ((HUFF_L_REM)/2)) - (1 << ((HUFF_L_REM + 1)/2)) + 1)
+#define HUFF_L_SIZE (HUFF_AC_SYMBOLS + HUFF_L_DUP + HUFF_L_UNUSED)
+#define HUFF_CODE_LARGE_LONG_ALIGNED (HUFF_L_SIZE + (-HUFF_L_SIZE & 0xf))
+
+#define COEF_BITS_OFFSET 0
+#define COEF_BITS_BITS 4
+#define ZERO_NUM1_OFFSET 4
+#define ZERO_NUM_BITS 7
+#define NB_OFFSET 11
+#define NB_BITS 5
+#define COEF1_OFFSET 16
+#define COEF_VALUE_BITS 16
+
+#define EXTRA_BITS_OFFSET COEF_BITS_OFFSET  // 2nd table offset bits
+#define EXTRA_BITS_BITS COEF_BITS_BITS
+
+#define SYM_OFFSET COEF_BITS_OFFSET
+
+#define MAKE_BITS(x, s)  (x) << (s)
+#define GETS_BITS(x, s, l)  (((x) >> (s)) & ((0x1L << (l)) - 1))
+
+#define MAKE_ZERO_NUM1(x) MAKE_BITS((x), ZERO_NUM1_OFFSET)
+#define MAKE_COEF_BITS(x) MAKE_BITS((x), COEF_BITS_OFFSET)
+#define MAKE_SYM(x) MAKE_BITS((x), SYM_OFFSET)
+#define MAKE_NB(x) MAKE_BITS((x), NB_OFFSET)
+#define MAKE_COEF1(x) (unsigned long long) MAKE_BITS((UINT16) (x), COEF1_OFFSET)
+#define MAKE_BASE(x) MAKE_BITS((x), COEF1_OFFSET)
+#define MAKE_EXTRA_BITS(x) MAKE_BITS((x), EXTRA_BITS_OFFSET)
+
+#define GET_ZERO_NUM1(x) GETS_BITS((x), ZERO_NUM1_OFFSET, ZERO_NUM_BITS)
+#define GET_COEF_BITS(x) GETS_BITS((x), COEF_BITS_OFFSET, COEF_BITS_BITS)
+#define GET_NB(x) GETS_BITS((x), NB_OFFSET, NB_BITS)
+#define GET_COEF1(x) GETS_BITS((x), COEF1_OFFSET, COEF_VALUE_BITS)
+#define GET_BASE(x) GETS_BITS((x), COEF1_OFFSET, COEF_VALUE_BITS)
+#define GET_EXTRA_BITS(x) GETS_BITS((x), EXTRA_BITS_OFFSET, EXTRA_BITS_BITS)
+#endif
 
 typedef struct {
   /* Basic tables: (element [0] of each array is unused) */
@@ -47,11 +92,11 @@ typedef struct {
    * if too long.  The next 8 bits of each entry contain the
    * symbol.
    */
-  int lookup[1 << HUFF_LOOKAHEAD];
+  int lookup[(1 << HUFF_LOOKAHEAD) + HUFF_CODE_LARGE_LONG_ALIGNED];
 } d_derived_tbl;
 
 /* Expand a Huffman table definition into the derived format */
-EXTERN(void) jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC,
+HIDE(EXTERN)(void) jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC,
                                      int tblno, d_derived_tbl **pdtbl);
 
 
@@ -175,7 +220,7 @@ typedef struct {                /* Bitreading working state within an MCU */
   (bits_left -= (nbits))
 
 /* Load up the bit buffer to a depth of at least nbits */
-EXTERN(boolean) jpeg_fill_bit_buffer(bitread_working_state *state,
+HIDE(EXTERN)(boolean) jpeg_fill_bit_buffer(bitread_working_state *state,
                                      register bit_buf_type get_buffer,
                                      register int bits_left, int nbits);
 
@@ -244,7 +289,7 @@ slowlabel: \
   }
 
 /* Out-of-line case for Huffman code fetching */
-EXTERN(int) jpeg_huff_decode(bitread_working_state *state,
+HIDE(EXTERN)(int) jpeg_huff_decode(bitread_working_state *state,
                              register bit_buf_type get_buffer,
                              register int bits_left, d_derived_tbl *htbl,
                              int min_bits);
diff --git a/src/jdhuff_opt.c b/src/jdhuff_opt.c
new file mode 100644
index 0000000..956ead2
--- /dev/null
+++ b/src/jdhuff_opt.c
@@ -0,0 +1,1050 @@
+/*
+ * jdhuff_opt.c
+ *
+ * This file was part of the Independent JPEG Group's software:
+ * Copyright (C) 1991-1997, Thomas G. Lane.
+ * libjpeg-turbo Modifications:
+ * Copyright (C) 2009-2011, 2016, 2018-2019, D. R. Commander.
+ * Copyright (C) 2018, Matthias RÃ¤ncker.
+ * For conditions of distribution and use, see the accompanying README.ijg
+ * file.
+ *
+ * This file contains Huffman entropy decoding routines.
+ *
+ * Much of the complexity here has to do with supporting input suspension.
+ * If the data source module demands suspension, we want to be able to back
+ * up to the start of the current MCU.  To do this, we copy state variables
+ * into local working storage, and update them back to the permanent
+ * storage only upon successful completion of an MCU.
+ *
+ * NOTE: All referenced figures are from
+ * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.
+ */
+
+#define JPEG_INTERNALS
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "jdhuff.h"             /* Declarations shared with jdphuff.c */
+#include "jpegcomp.h"
+#include "jstdhuff.c"
+
+
+/*
+ * Expanded entropy decoder object for Huffman decoding.
+ *
+ * The savable_state subrecord contains fields that change within an MCU,
+ * but must not be updated permanently until we complete the MCU.
+ */
+
+typedef struct {
+  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
+} savable_state;
+
+typedef struct {
+  struct jpeg_entropy_decoder pub; /* public fields */
+
+  /* These fields are loaded into local variables at start of each MCU.
+   * In case of suspension, we exit WITHOUT updating them.
+   */
+  bitread_perm_state bitstate;  /* Bit buffer at start of MCU */
+  savable_state saved;          /* Other state at start of MCU */
+
+  /* These fields are NOT loaded into local working state. */
+  unsigned int restarts_to_go;  /* MCUs left in this restart interval */
+
+  /* Pointers to derived tables (these workspaces have image lifespan) */
+  d_derived_tbl *dc_derived_tbls[NUM_HUFF_TBLS];
+  d_derived_tbl *ac_derived_tbls[NUM_HUFF_TBLS];
+
+  /* Precalculated info set up by start_pass for use in decode_mcu: */
+
+  /* Pointers to derived tables to be used for each block within an MCU */
+  d_derived_tbl *dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
+  d_derived_tbl *ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
+  /* Whether we care about the DC and AC coefficient values for each block */
+  boolean dc_needed[D_MAX_BLOCKS_IN_MCU];
+  boolean ac_needed[D_MAX_BLOCKS_IN_MCU];
+} huff_entropy_decoder;
+
+typedef huff_entropy_decoder *huff_entropy_ptr;
+
+/*
+ * Figure F.12: extend sign bit.
+ * On some machines, a shift and add will be faster than a table lookup.
+ */
+
+#define AVOID_TABLES
+#ifdef AVOID_TABLES
+
+#define NEG_1  ((unsigned int)-1)
+#define HUFF_EXTEND(x, s) \
+  ((x) + ((((x) - (1 << ((s) - 1))) >> 31) & (((NEG_1) << (s)) + 1)))
+
+#else
+
+#define HUFF_EXTEND(x, s) \
+  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))
+
+static const int extend_test[16] = {   /* entry n is 2**(n-1) */
+  0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
+  0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000
+};
+
+static const int extend_offset[16] = { /* entry n is (-1 << n) + 1 */
+  0, ((-1) << 1) + 1, ((-1) << 2) + 1, ((-1) << 3) + 1, ((-1) << 4) + 1,
+  ((-1) << 5) + 1, ((-1) << 6) + 1, ((-1) << 7) + 1, ((-1) << 8) + 1,
+  ((-1) << 9) + 1, ((-1) << 10) + 1, ((-1) << 11) + 1, ((-1) << 12) + 1,
+  ((-1) << 13) + 1, ((-1) << 14) + 1, ((-1) << 15) + 1
+};
+
+#endif /* AVOID_TABLES */
+
+/*
+ * Initialize for a Huffman-compressed scan.
+ */
+
+METHODDEF(void)
+start_pass_huff_decoder(j_decompress_ptr cinfo)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;
+  int ci, blkn, dctbl, actbl;
+  d_derived_tbl **pdtbl;
+  jpeg_component_info *compptr;
+
+  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
+   * This ought to be an error condition, but we make it a warning because
+   * there are some baseline files out there with all zeroes in these bytes.
+   */
+  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2 - 1 ||
+      cinfo->Ah != 0 || cinfo->Al != 0)
+    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
+
+  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
+    compptr = cinfo->cur_comp_info[ci];
+    dctbl = compptr->dc_tbl_no;
+    actbl = compptr->ac_tbl_no;
+    /* Compute derived values for Huffman tables */
+    /* We may do this more than once for a table, but it's not expensive */
+    pdtbl = (d_derived_tbl **)(entropy->dc_derived_tbls) + dctbl;
+    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl, pdtbl);
+    pdtbl = (d_derived_tbl **)(entropy->ac_derived_tbls) + actbl;
+    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl, pdtbl);
+    /* Initialize DC predictions to 0 */
+    entropy->saved.last_dc_val[ci] = 0;
+  }
+
+  /* Precalculate decoding info for each block in an MCU of this scan */
+  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
+    ci = cinfo->MCU_membership[blkn];
+    compptr = cinfo->cur_comp_info[ci];
+    /* Precalculate which table to use for each block */
+    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
+    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
+    /* Decide whether we really care about the coefficient values */
+    if (compptr->component_needed) {
+      entropy->dc_needed[blkn] = TRUE;
+      /* we don't need the ACs if producing a 1/8th-size image */
+      entropy->ac_needed[blkn] = (compptr->_DCT_scaled_size > 1);
+    } else {
+      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
+    }
+  }
+
+  /* Initialize bitread state variables */
+  entropy->bitstate.bits_left = 0;
+  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
+  entropy->pub.insufficient_data = FALSE;
+
+  /* Initialize restart counter */
+  entropy->restarts_to_go = cinfo->restart_interval;
+}
+
+LOCAL(void)
+jpeg_make_d_ac_derived_tbl(JHUFF_TBL *htbl, d_derived_tbl *dtbl, const unsigned int* huffcode)
+{
+  // Look up tables for AC, index is huffman code, value is the symbol and the length
+  // htbl->bits[l], number of symbol that of which the code length is l
+  // htbl->huffval[l], symbol in order
+  int p, i, l, lookbits, ctr;
+  // nb <= LOOKAHEAD
+  p = 0;
+  int coef0;
+  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
+    for (i = 1; i <= (int)htbl->bits[l]; i++, p++) {
+      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
+      /* Generate left-justified code followed by all possible bit sequences */
+      UINT8 rs = htbl->huffval[p]; // run length symbol (zero num + coeff bits)
+      UINT8 coef_bits = rs & 0x0F;
+      if ((l + coef_bits) <= HUFF_LOOKAHEAD) {
+        // save DCT coeffs in higher bits
+        for (coef0 = 0; coef0 < (1 << coef_bits); coef0++) {
+          INT16 coef_value = HUFF_EXTEND(coef0, coef_bits);  // save value after extended.
+          lookbits = (huffcode[p] << (HUFF_LOOKAHEAD - l)) | (coef0 << (HUFF_LOOKAHEAD - l - coef_bits));
+          for (ctr = 1 << (HUFF_LOOKAHEAD - l - coef_bits); ctr > 0; ctr--) {
+            if (coef_bits == 0 && (rs >> 4) != 0xF) { // the low 4 bits are number of coef bits
+              // use 63 to exit the loop when symbol is 00
+              dtbl->lookup[lookbits] = MAKE_COEF1(coef_value) | MAKE_NB(l + coef_bits) | MAKE_ZERO_NUM1(63);
+             } else { // F0 and other symbols
+              // save the low 4 bits
+              dtbl->lookup[lookbits] = MAKE_COEF1(coef_value) | MAKE_NB(l + coef_bits) | MAKE_ZERO_NUM1(rs >> 4);
+            }
+            lookbits++;
+          }
+        }
+      } else {
+        // same as the original lookup table
+        lookbits = huffcode[p] << (HUFF_LOOKAHEAD - l);
+        for (ctr = 1 << (HUFF_LOOKAHEAD - l); ctr > 0; ctr--) {
+          dtbl->lookup[lookbits] = MAKE_NB(l) | MAKE_SYM(rs);
+          lookbits++;
+        }
+      }
+    }
+  }
+  // nb > LOOKAHEAD
+  int offset = 0;
+  int base = 1 << HUFF_LOOKAHEAD;
+  int short_tbl_index = 0xFFFFFFFF;
+  int cur_long_tbl_base = 1 << HUFF_LOOKAHEAD;
+  int left;
+  int offset_bit = 0;
+  int first = p;  // the index of the first code of this length.
+  int max_code_len;
+  for (max_code_len = MAX_HUFF_CODE_LEN; max_code_len >= 1; max_code_len--) {
+    if (htbl->bits[max_code_len]) {
+        break;
+    }
+  }
+  for (l = HUFF_LOOKAHEAD + 1; l <= MAX_HUFF_CODE_LEN; l++) {
+    for (i = 1; i <= (int)htbl->bits[l]; i++, p++) {
+      UINT8 rs = htbl->huffval[p]; // run length symbol (zero num + coeff bits)
+      UINT8 coef_bits = rs & 0x0f;
+      // similar as 1st table as before
+      lookbits = huffcode[p] >> (l - HUFF_LOOKAHEAD); // index in 1st table
+      // check if a new 2nd tbl should be created
+      if (lookbits != short_tbl_index) {
+        short_tbl_index = lookbits;
+        cur_long_tbl_base += offset;
+        offset = 0;
+        offset_bit = l - HUFF_LOOKAHEAD;
+        left = (1 << offset_bit) - (htbl->bits[l] - (p - first));
+        while (offset_bit + HUFF_LOOKAHEAD < max_code_len && left > 0) {
+          offset_bit++;
+          left = (left << 1) - htbl->bits[offset_bit + HUFF_LOOKAHEAD];
+        }
+      }
+      base = cur_long_tbl_base;
+      // set 1st table value
+      dtbl->lookup[lookbits] = MAKE_BASE(base) | MAKE_NB(l) | MAKE_EXTRA_BITS(offset_bit);
+      // set 2nd table value
+      // index is guarenteed to be valid
+      for (ctr = 0; ctr < (1 << (offset_bit - (l - HUFF_LOOKAHEAD))); ctr++) {
+        if (coef_bits == 0) {
+          dtbl->lookup[base + offset] = MAKE_NB(l) | MAKE_SYM(rs) | MAKE_COEF_BITS(0xF);
+        } else {
+          dtbl->lookup[base + offset] = MAKE_NB(l) | MAKE_SYM(rs);
+        }
+        offset++;
+      }
+    }
+    first = p;
+  }
+}
+
+/*
+ * Compute the derived values for a Huffman table.
+ * This routine also performs some validation checks on the table.
+ *
+ * Note this is also used by jdphuff.c.
+ */
+
+GLOBAL(void)
+jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC, int tblno,
+                        d_derived_tbl **pdtbl)
+{
+  JHUFF_TBL *htbl;
+  d_derived_tbl *dtbl;
+  int p, i, l, si, numsymbols;
+  int lookbits, ctr;
+  char huffsize[257];
+  unsigned int huffcode[257];
+  unsigned int code;
+
+  /* Note that huffsize[] and huffcode[] are filled in code-length order,
+   * paralleling the order of the symbols themselves in htbl->huffval[].
+   */
+
+  /* Find the input Huffman table */
+  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+  htbl =
+    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
+  if (htbl == NULL)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+
+  /* Allocate a workspace if we haven't already done so. */
+  if (*pdtbl == NULL)
+    *pdtbl = (d_derived_tbl *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
+                                  sizeof(d_derived_tbl));
+  dtbl = *pdtbl;
+  dtbl->pub = htbl;             /* fill in back link */
+
+  /* Figure C.1: make table of Huffman code length for each symbol */
+
+  p = 0;
+  for (l = 1; l <= MAX_HUFF_CODE_LEN; l++) {
+    i = (int)htbl->bits[l];
+    if (i < 0 || p + i > 256)   /* protect against table overrun, 256 is the max number of symbols */
+      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    while (i--)
+      huffsize[p++] = (char)l;
+  }
+  huffsize[p] = 0;
+  numsymbols = p;
+
+  /* Figure C.2: generate the codes themselves */
+  /* We also validate that the counts represent a legal Huffman code tree. */
+
+  code = 0;
+  si = huffsize[0];
+  p = 0;
+  while (huffsize[p]) {
+    while (((int)huffsize[p]) == si) {
+      huffcode[p++] = code;
+      code++;
+    }
+    /* code is now 1 more than the last code used for codelength si; but
+     * it must still fit in si bits, since no code is allowed to be all ones.
+     */
+    if (((JLONG)code) >= (((JLONG)1) << si))
+      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    code <<= 1;
+    si++;
+  }
+
+  /* Figure F.15: generate decoding tables for bit-sequential decoding */
+
+  p = 0;
+  for (l = 1; l <= MAX_HUFF_CODE_LEN; l++) {
+    if (htbl->bits[l]) {
+      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
+       * minus the minimum code of length l
+       */
+      dtbl->valoffset[l] = (JLONG)p - (JLONG)huffcode[p];
+      p += htbl->bits[l];
+      dtbl->maxcode[l] = huffcode[p - 1]; /* maximum code of length l */
+    } else {
+      dtbl->maxcode[l] = -1;    /* -1 if no codes of this length */
+    }
+  }
+  dtbl->valoffset[17] = 0;  /* 17 is always max symbol length in Huffman spec */
+  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates, 17 has the same meaning above */
+
+  /* Compute lookahead tables to speed up decoding.
+   * First we set all the table entries to 0, indicating "too long";
+   * then we iterate through the Huffman codes that are short enough and
+   * fill in all the entries that correspond to bit sequences starting
+   * with that code.
+   */
+
+  for (i = 0; i < (1 << HUFF_LOOKAHEAD); i++) {
+    dtbl->lookup[i] = (HUFF_LOOKAHEAD + 1) << HUFF_LOOKAHEAD;
+  }
+  for (; i < (1 << HUFF_LOOKAHEAD) + HUFF_CODE_LARGE_LONG_ALIGNED; i++) {
+    dtbl->lookup[i] = 0;
+  }
+
+  if (!isDC) {
+    jpeg_make_d_ac_derived_tbl(htbl, dtbl, huffcode);
+  } else {
+    for (i = 0; i < (1 << HUFF_LOOKAHEAD); i++)
+      dtbl->lookup[i] = (HUFF_LOOKAHEAD + 1) << HUFF_LOOKAHEAD;
+    p = 0;
+    for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
+      for (i = 1; i <= (int)htbl->bits[l]; i++, p++) {
+        /* l = current code's length, p = its index in huffcode[] & huffval[]. */
+        /* Generate left-justified code followed by all possible bit sequences */
+        lookbits = huffcode[p] << (HUFF_LOOKAHEAD - l);
+        for (ctr = 1 << (HUFF_LOOKAHEAD - l); ctr > 0; ctr--) {
+          dtbl->lookup[lookbits] = (l << HUFF_LOOKAHEAD) | htbl->huffval[p];
+          lookbits++;
+        }
+      }
+    }
+  }
+
+  /* Validate symbols as being reasonable.
+   * For AC tables, we make no check, but accept all byte values 0..255.
+   * For DC tables, we require the symbols to be in range 0..15.
+   * (Tighter bounds could be applied depending on the data depth and mode,
+   * but this is sufficient to ensure safe decoding.)
+   */
+  if (isDC) {
+    for (i = 0; i < numsymbols; i++) {
+      int sym = htbl->huffval[i];
+      if (sym < 0 || sym > 15)  // 15 is the max value of DC symbol
+        ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    }
+  }
+}
+
+
+/*
+ * Out-of-line code for bit fetching (shared with jdphuff.c).
+ * See jdhuff.h for info about usage.
+ * Note: current values of get_buffer and bits_left are passed as parameters,
+ * but are returned in the corresponding fields of the state struct.
+ *
+ * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
+ * of get_buffer to be used.  (On machines with wider words, an even larger
+ * buffer could be used.)  However, on some machines 32-bit shifts are
+ * quite slow and take time proportional to the number of places shifted.
+ * (This is true with most PC compilers, for instance.)  In this case it may
+ * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
+ * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
+ */
+
+#ifdef SLOW_SHIFT_32
+#define MIN_GET_BITS  15        /* minimum allowable value */
+#else
+#define MIN_GET_BITS  (BIT_BUF_SIZE - 7)
+#endif
+
+
+GLOBAL(boolean)
+jpeg_fill_bit_buffer(bitread_working_state *state,
+                     register bit_buf_type get_buffer, register int bits_left,
+                     int nbits)
+/* Load up the bit buffer to a depth of at least nbits */
+{
+  /* Copy heavily used state fields into locals (hopefully registers) */
+  register const JOCTET *next_input_byte = state->next_input_byte;
+  register size_t bytes_in_buffer = state->bytes_in_buffer;
+  j_decompress_ptr cinfo = state->cinfo;
+
+  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
+  /* (It is assumed that no request will be for more than that many bits.) */
+  /* We fail to do so only if we hit a marker or are forced to suspend. */
+
+  if (cinfo->unread_marker == 0) {      /* cannot advance past a marker */
+    while (bits_left < MIN_GET_BITS) {
+      register int c;
+
+      /* Attempt to read a byte */
+      if (bytes_in_buffer == 0) {
+        if (!(*cinfo->src->fill_input_buffer) (cinfo))
+          return FALSE;
+        next_input_byte = cinfo->src->next_input_byte;
+        bytes_in_buffer = cinfo->src->bytes_in_buffer;
+      }
+      bytes_in_buffer--;
+      c = *next_input_byte++;
+
+      /* If it's 0xFF, check and discard stuffed zero byte */
+      if (c == 0xFF) {
+        /* Loop here to discard any padding FF's on terminating marker,
+         * so that we can save a valid unread_marker value.  NOTE: we will
+         * accept multiple FF's followed by a 0 as meaning a single FF data
+         * byte.  This data pattern is not valid according to the standard.
+         */
+        do {
+          if (bytes_in_buffer == 0) {
+            if (!(*cinfo->src->fill_input_buffer) (cinfo))
+              return FALSE;
+            next_input_byte = cinfo->src->next_input_byte;
+            bytes_in_buffer = cinfo->src->bytes_in_buffer;
+          }
+          bytes_in_buffer--;
+          c = *next_input_byte++;
+        } while (c == 0xFF);
+
+        if (c == 0) {
+          /* Found FF/00, which represents an FF data byte */
+          c = 0xFF;
+        } else {
+          /* Oops, it's actually a marker indicating end of compressed data.
+           * Save the marker code for later use.
+           * Fine point: it might appear that we should save the marker into
+           * bitread working state, not straight into permanent state.  But
+           * once we have hit a marker, we cannot need to suspend within the
+           * current MCU, because we will read no more bytes from the data
+           * source.  So it is OK to update permanent state right away.
+           */
+          cinfo->unread_marker = c;
+          /* See if we need to insert some fake zero bits. */
+          goto no_more_bytes;
+        }
+      }
+
+      /* OK, load c into get_buffer */
+      get_buffer = (get_buffer << 8) | c; // read 8 bits every time
+      bits_left += 8; // read 8 bits every time
+    } /* end while */
+  } else {
+no_more_bytes:
+    /* We get here if we've read the marker that terminates the compressed
+     * data segment.  There should be enough bits in the buffer register
+     * to satisfy the request; if so, no problem.
+     */
+    if (nbits > bits_left) {
+      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
+       * the data stream, so that we can produce some kind of image.
+       * We use a nonvolatile flag to ensure that only one warning message
+       * appears per data segment.
+       */
+      if (!cinfo->entropy->insufficient_data) {
+        WARNMS(cinfo, JWRN_HIT_MARKER);
+        cinfo->entropy->insufficient_data = TRUE;
+      }
+      /* Fill the buffer with zero bits */
+      get_buffer <<= MIN_GET_BITS - bits_left;
+      bits_left = MIN_GET_BITS;
+    }
+  }
+
+  /* Unload the local registers */
+  state->next_input_byte = next_input_byte;
+  state->bytes_in_buffer = bytes_in_buffer;
+  state->get_buffer = get_buffer;
+  state->bits_left = bits_left;
+
+  return TRUE;
+}
+
+
+/* Macro version of the above, which performs much better but does not
+   handle markers.  We have to hand off any blocks with markers to the
+   slower routines. */
+
+#define GET_BYTE { \
+  register int c0, c1; \
+  c0 = *buffer++; \
+  c1 = *buffer; \
+  /* Pre-execute most common case */ \
+  get_buffer = (get_buffer << 8) | c0; \
+  bits_left += 8; \
+  if (c0 == 0xFF) { \
+    /* Pre-execute case of FF/00, which represents an FF data byte */ \
+    buffer++; \
+    if (c1 != 0) { \
+      /* Oops, it's actually a marker indicating end of compressed data. */ \
+      cinfo->unread_marker = c1; \
+      /* Back out pre-execution and fill the buffer with zero bits */ \
+      buffer -= 2; \
+      get_buffer &= ~0xFF; \
+    } \
+  } \
+}
+
+#if SIZEOF_SIZE_T == 8 || defined(_WIN64) || (defined(__x86_64__) && defined(__ILP32__))
+
+/* Pre-fetch 48 bytes, because the holding register is 64-bit */
+#define FILL_BIT_BUFFER_FAST \
+  if (bits_left <= 16) { \
+    GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE \
+  }
+
+#else
+
+/* Pre-fetch 16 bytes, because the holding register is 32-bit */
+#define FILL_BIT_BUFFER_FAST \
+  if (bits_left <= 16) { \
+    GET_BYTE GET_BYTE \
+  }
+
+#endif
+
+
+/*
+ * Out-of-line code for Huffman code decoding.
+ * See jdhuff.h for info about usage.
+ */
+
+GLOBAL(int)
+jpeg_huff_decode(bitread_working_state *state,
+                 register bit_buf_type get_buffer, register int bits_left,
+                 d_derived_tbl *htbl, int min_bits)
+{
+  register int l = min_bits;
+  register JLONG code;
+
+  /* HUFF_DECODE has determined that the code is at least min_bits */
+  /* bits long, so fetch that many bits in one swoop. */
+
+  CHECK_BIT_BUFFER(*state, l, return -1);
+  code = GET_BITS(l);
+
+  /* Collect the rest of the Huffman code one bit at a time. */
+  /* This is per Figure F.16. */
+
+  while (code > htbl->maxcode[l]) {
+    code <<= 1;
+    CHECK_BIT_BUFFER(*state, 1, return -1);
+    code |= GET_BITS(1);
+    l++;
+  }
+
+  /* Unload the local registers */
+  state->get_buffer = get_buffer;
+  state->bits_left = bits_left;
+
+  /* With garbage input we may reach the sentinel value l = 17. */
+
+  if (l > MAX_HUFF_CODE_LEN) {
+    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
+    return 0;                   /* fake a zero as the safest result */
+  }
+
+  return htbl->pub->huffval[(int)(code + htbl->valoffset[l])];
+}
+
+/*
+ * Check for a restart marker & resynchronize decoder.
+ * Returns FALSE if must suspend.
+ */
+
+LOCAL(boolean)
+process_restart(j_decompress_ptr cinfo)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;
+  int ci;
+
+  /* Throw away any unused bits remaining in bit buffer; */
+  /* include any full bytes in next_marker's count of discarded bytes */
+  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8; // 8 bits in a byte
+  entropy->bitstate.bits_left = 0;
+
+  /* Advance past the RSTn marker */
+  if (!(*cinfo->marker->read_restart_marker) (cinfo))
+    return FALSE;
+
+  /* Re-initialize DC predictions to 0 */
+  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
+    entropy->saved.last_dc_val[ci] = 0;
+
+  /* Reset restart counter */
+  entropy->restarts_to_go = cinfo->restart_interval;
+
+  /* Reset out-of-data flag, unless read_restart_marker left us smack up
+   * against a marker.  In that case we will end up treating the next data
+   * segment as empty, and we can avoid producing bogus output pixels by
+   * leaving the flag set.
+   */
+  if (cinfo->unread_marker == 0)
+    entropy->pub.insufficient_data = FALSE;
+
+  return TRUE;
+}
+
+
+#if defined(__has_feature)
+#if __has_feature(undefined_behavior_sanitizer)
+__attribute__((no_sanitize("signed-integer-overflow"),
+               no_sanitize("unsigned-integer-overflow")))
+#endif
+#endif
+LOCAL(boolean)
+decode_mcu_slow(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;
+  BITREAD_STATE_VARS;
+  int blkn;
+  savable_state state;
+  /* Outer loop handles each block in the MCU */
+
+  /* Load up working state */
+  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
+  state = entropy->saved;
+
+  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
+    JBLOCKROW block = MCU_data ? MCU_data[blkn] : NULL;
+    d_derived_tbl *dctbl = entropy->dc_cur_tbls[blkn];
+    d_derived_tbl *actbl = entropy->ac_cur_tbls[blkn];
+    register int s, k, r;
+
+    /* Decode a single block's worth of coefficients */
+
+    /* Section F.2.2.1: decode the DC coefficient difference */
+    HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
+    if (s) {
+      CHECK_BIT_BUFFER(br_state, s, return FALSE);
+      r = GET_BITS(s);
+      s = HUFF_EXTEND(r, s);
+    }
+
+    if (entropy->dc_needed[blkn]) {
+      /* Convert DC difference to actual value, update last_dc_val */
+      int ci = cinfo->MCU_membership[blkn];
+      /* Certain malformed JPEG images produce repeated DC coefficient
+       * differences of 2047 or -2047, which causes state.last_dc_val[ci] to
+       * grow until it overflows or underflows a 32-bit signed integer.  This
+       * behavior is, to the best of our understanding, innocuous, and it is
+       * unclear how to work around it without potentially affecting
+       * performance.  Thus, we (hopefully temporarily) suppress UBSan integer
+       * overflow errors for this function and decode_mcu_fast().
+       */
+      s += state.last_dc_val[ci];
+      state.last_dc_val[ci] = s;
+      if (block) {
+        /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
+        (*block)[0] = (JCOEF)s;
+      }
+    }
+
+    if (entropy->ac_needed[blkn] && block) {
+      /* Section F.2.2.2: decode the AC coefficients */
+      /* Since zeroes are skipped, output area must be cleared beforehand */
+      for (k = 1; k < DCTSIZE2; k++) {
+        register int nb, look;
+        if (bits_left < HUFF_LOOKAHEAD) {
+          if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0)) {
+            return FALSE;
+          }
+          get_buffer = br_state.get_buffer;
+          bits_left = br_state.bits_left;
+          if (bits_left < HUFF_LOOKAHEAD) {
+            nb = 1;
+            goto slowlabel;
+          }
+        }
+        look = PEEK_BITS(HUFF_LOOKAHEAD);
+        r = actbl->lookup[look];
+        nb = GET_NB(r);
+        unsigned int zero_num;
+        unsigned int coef_bits = GET_COEF_BITS(r);
+        if (nb <= HUFF_LOOKAHEAD) {
+          DROP_BITS(nb);
+          s = actbl->lookup[look] & ((1 << HUFF_LOOKAHEAD) - 1);
+          zero_num = GET_ZERO_NUM1(r);
+          k += zero_num;
+          if (coef_bits == 0) {
+            s = GET_COEF1(r);
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          } else {
+            CHECK_BIT_BUFFER(br_state, (int)coef_bits, return FALSE);
+            r = GET_BITS(coef_bits);
+            s = HUFF_EXTEND(r, coef_bits);
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          }
+        } else {
+        slowlabel:
+          nb = 1;
+          if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, actbl, nb)) < 0) { return FALSE; }
+          get_buffer = br_state.get_buffer;
+          bits_left = br_state.bits_left;
+
+          r = s >> 4; // get higher 4 bits
+          s &= 15;  // use 15 as a mask to get the lower 4 bits
+
+          if (s) {
+            k += r;
+            CHECK_BIT_BUFFER(br_state, s, return FALSE);
+            r = GET_BITS(s);
+            s = HUFF_EXTEND(r, s);
+            /* Output coefficient in natural (dezigzagged) order.
+             * Note: the extra entries in jpeg_natural_order[] will save us
+             * if k >= DCTSIZE2, which could happen if the data is corrupted.
+             */
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          } else {
+            if (r != 15)  // 15 = 0xF0 is a special symbol means 16 zeros in RLE coding
+              break;
+            k += 15;  // use 15 to skip DCT coef zero
+          }
+        }
+      }
+    } else {
+      /* Section F.2.2.2: decode the AC coefficients */
+      /* In this path we just discard the values */
+      for (k = 1; k < DCTSIZE2; k++) {
+        register int nb, look;
+        if (bits_left < HUFF_LOOKAHEAD) {
+          if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0)) {
+            return FALSE;
+          }
+          get_buffer = br_state.get_buffer;
+          bits_left = br_state.bits_left;
+          if (bits_left < HUFF_LOOKAHEAD) {
+            nb = 1;
+            goto slowlabel2;
+          }
+        }
+        look = PEEK_BITS(HUFF_LOOKAHEAD);
+        r = actbl->lookup[look];
+        nb = GET_NB(r);
+        unsigned int zero_num;
+        unsigned int coef_bits = GET_COEF_BITS(r);
+        if (nb <= HUFF_LOOKAHEAD) {
+          DROP_BITS(nb);
+          s = actbl->lookup[look] & ((1 << HUFF_LOOKAHEAD) - 1);
+          zero_num = GET_ZERO_NUM1(r);
+          k += zero_num;
+          if (coef_bits != 0) {
+            CHECK_BIT_BUFFER(br_state, (int)coef_bits, return FALSE);
+            DROP_BITS(coef_bits);
+          }
+        } else {
+        slowlabel2:
+          nb = 1;
+          if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, actbl, nb)) < 0) { return FALSE; }
+          get_buffer = br_state.get_buffer;
+          bits_left = br_state.bits_left;
+
+          r = s >> 4; // get higher 4 bits
+          s &= 15; // use 15 as a mask to get the lower 4 bits
+
+          if (s) {
+            k += r;
+            CHECK_BIT_BUFFER(br_state, s, return FALSE);
+            DROP_BITS(s);
+          } else {
+            if (r != 15) // 15 = 0xF0 is a special symbol means 16 zeros in RLE coding
+              break;
+            k += 15;  // use 15 to skip DCT coef zero
+          }
+        }
+      }
+    }
+  }
+
+  /* Completed MCU, so update state */
+  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
+  entropy->saved = state;
+  return TRUE;
+}
+
+
+#if defined(__has_feature)
+#if __has_feature(undefined_behavior_sanitizer)
+__attribute__((no_sanitize("signed-integer-overflow"),
+               no_sanitize("unsigned-integer-overflow")))
+#endif
+#endif
+LOCAL(boolean)
+decode_mcu_fast(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;
+  BITREAD_STATE_VARS;
+  JOCTET *buffer;
+  int blkn;
+  savable_state state;
+  /* Outer loop handles each block in the MCU */
+
+  /* Load up working state */
+  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
+  buffer = (JOCTET *)br_state.next_input_byte;
+  state = entropy->saved;
+
+  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
+    JBLOCKROW block = MCU_data ? MCU_data[blkn] : NULL;
+    d_derived_tbl *dctbl = entropy->dc_cur_tbls[blkn];
+    d_derived_tbl *actbl = entropy->ac_cur_tbls[blkn];
+    register int s, k, r, l;
+
+    HUFF_DECODE_FAST(s, l, dctbl);
+    if (s) {
+      FILL_BIT_BUFFER_FAST
+      r = GET_BITS(s);
+      s = HUFF_EXTEND(r, s);
+    }
+
+    if (entropy->dc_needed[blkn]) {
+      int ci = cinfo->MCU_membership[blkn];
+      /* Refer to the comment in decode_mcu_slow() regarding the supression of
+       * a UBSan integer overflow error in this line of code.
+       */
+      s += state.last_dc_val[ci];
+      state.last_dc_val[ci] = s;
+      if (block)
+        (*block)[0] = (JCOEF)s;
+    }
+
+    if (entropy->ac_needed[blkn] && block) {
+      for (k = 1; k < DCTSIZE2; k++) {
+        FILL_BIT_BUFFER_FAST;
+        r = PEEK_BITS(HUFF_LOOKAHEAD);    // åè¯»ålook_aheadä½
+        r = actbl->lookup[r];
+        l = GET_NB(r);
+        unsigned int zero_num;
+        unsigned int coef_bits = GET_COEF_BITS(r);
+
+        if (l <= HUFF_LOOKAHEAD) {
+          zero_num = GET_ZERO_NUM1(r);
+          DROP_BITS(l);
+          if (coef_bits == 0) {
+            s = GET_COEF1(r);
+            k += zero_num;
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          } else {
+            FILL_BIT_BUFFER_FAST
+            r = GET_BITS(coef_bits);
+            s = HUFF_EXTEND(r, coef_bits);
+            k += zero_num;
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          }
+        } else {
+          unsigned int base = GET_BASE(r);  // é«16ä½ä¸ºbase
+          unsigned int offset_bits = GET_EXTRA_BITS(r);  // ä½8ä½ä¸ºoffset_bits, l = nb ä¸ºäºçº§è¡¨çæå¤§ç é¿
+          r = PEEK_BITS(l); // åHUFF_LOOKAHEADä½å·²ä½¿ç¨ï¼åªä½¿ç¨ä½nb - HUFF_LOOKAHEADä½, åä½offset_bitsä½ä¸ºäºçº§è¡¨ç´¢å¼
+          s = actbl->lookup[base + (r & ((1 << offset_bits) - 1))];
+          l = GET_NB(s); // å®éç é¿
+          coef_bits = GET_COEF_BITS(s);
+          zero_num = GET_ZERO_NUM1(s);
+          DROP_BITS(l);
+          if (coef_bits == 0xF) {
+            if (zero_num != 0xF) {
+              break;
+            } else {
+              k += 15; // use 15 to skip DCT coef zero
+            }
+          } else {
+            FILL_BIT_BUFFER_FAST
+            r = GET_BITS(coef_bits);
+            s = HUFF_EXTEND(r, coef_bits);
+            k += zero_num;
+            (*block)[jpeg_natural_order[k]] = (JCOEF)s;
+          }
+        }
+      }
+    } else {
+      for (k = 1; k < DCTSIZE2; k++) {
+        FILL_BIT_BUFFER_FAST;
+        r = PEEK_BITS(HUFF_LOOKAHEAD);    // åè¯»ålook_aheadä½
+        r = actbl->lookup[r];
+        l = GET_NB(r);
+        unsigned int zero_num;
+        unsigned int coef_bits = GET_COEF_BITS(r);
+
+        if (l <= HUFF_LOOKAHEAD) {
+          zero_num = GET_ZERO_NUM1(r);
+          DROP_BITS(l);
+          if (coef_bits == 0) {
+            s = GET_COEF1(r);
+            k += zero_num;
+          } else {
+            FILL_BIT_BUFFER_FAST
+            DROP_BITS(coef_bits);
+            k += zero_num;
+          }
+        } else {
+          unsigned int base = GET_BASE(r);  // é«16ä½ä¸ºbase
+          unsigned int offset_bits = GET_EXTRA_BITS(r);  // ä½8ä½ä¸ºoffset_bits, l = nb ä¸ºäºçº§è¡¨çæå¤§ç é¿
+          r = PEEK_BITS(l); // åHUFF_LOOKAHEADä½å·²ä½¿ç¨ï¼åªä½¿ç¨ä½nb - HUFF_LOOKAHEADä½, åä½offset_bitsä½ä¸ºäºçº§è¡¨ç´¢å¼
+          s = actbl->lookup[base + (r & ((1 << offset_bits) - 1))];
+          l = GET_NB(s); // å®éç é¿
+          coef_bits = GET_COEF_BITS(s);
+          zero_num = GET_ZERO_NUM1(s);
+          DROP_BITS(l);
+          if (coef_bits == 0xF) {
+            if (zero_num != 0xF) {
+              break;
+            } else {
+              k += 15; // use 15 to skip DCT coef zero
+            }
+          } else {
+            FILL_BIT_BUFFER_FAST
+            DROP_BITS(coef_bits);
+            k += zero_num;
+          }
+        }
+      }
+    }
+  }
+
+  if (cinfo->unread_marker != 0) {
+    cinfo->unread_marker = 0;
+    return FALSE;
+  }
+
+  br_state.bytes_in_buffer -= (buffer - br_state.next_input_byte);
+  br_state.next_input_byte = buffer;
+  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
+  entropy->saved = state;
+  return TRUE;
+}
+
+
+/*
+ * Decode and return one MCU's worth of Huffman-compressed coefficients.
+ * The coefficients are reordered from zigzag order into natural array order,
+ * but are not dequantized.
+ *
+ * The i'th block of the MCU is stored into the block pointed to by
+ * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
+ * (Wholesale zeroing is usually a little faster than retail...)
+ *
+ * Returns FALSE if data source requested suspension.  In that case no
+ * changes have been made to permanent state.  (Exception: some output
+ * coefficients may already have been assigned.  This is harmless for
+ * this module, since we'll just re-assign them on the next call.)
+ */
+
+#define BUFSIZE  (DCTSIZE2 * 8)
+
+METHODDEF(boolean)
+decode_mcu(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;
+  int usefast = 1;
+
+  /* Process restart marker if needed; may have to suspend */
+  if (cinfo->restart_interval) {
+    if (entropy->restarts_to_go == 0)
+      if (!process_restart(cinfo))
+        return FALSE;
+    usefast = 0;
+  }
+
+  if (cinfo->src->bytes_in_buffer < BUFSIZE * (size_t)cinfo->blocks_in_MCU ||
+      cinfo->unread_marker != 0)
+    usefast = 0;
+
+  /* If we've run out of data, just leave the MCU set to zeroes.
+   * This way, we return uniform gray for the remainder of the segment.
+   */
+  if (!entropy->pub.insufficient_data) {
+    if (usefast) {
+      if (!decode_mcu_fast(cinfo, MCU_data)) goto use_slow;
+    } else {
+use_slow:
+      if (!decode_mcu_slow(cinfo, MCU_data)) return FALSE;
+    }
+  }
+
+  /* Account for restart interval (no-op if not using restarts) */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
+
+  return TRUE;
+}
+
+
+/*
+ * Module initialization routine for Huffman entropy decoding.
+ */
+
+GLOBAL(void)
+jinit_huff_decoder(j_decompress_ptr cinfo)
+{
+  huff_entropy_ptr entropy;
+  int i;
+
+  /* Motion JPEG frames typically do not include the Huffman tables if they
+     are the default tables.  Thus, if the tables are not set by the time
+     the Huffman decoder is initialized (usually within the body of
+     jpeg_start_decompress()), we set them to default values. */
+  std_huff_tables((j_common_ptr)cinfo);
+
+  entropy = (huff_entropy_ptr)
+    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
+                                sizeof(huff_entropy_decoder));
+  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;
+  entropy->pub.start_pass = start_pass_huff_decoder;
+  entropy->pub.decode_mcu = decode_mcu;
+
+  /* Mark tables unallocated */
+  for (i = 0; i < NUM_HUFF_TBLS; i++) {
+    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
+  }
+}
diff --git a/src/jdphuff.c b/src/jdphuff.c
index bf97333..3f0c263 100644
--- a/src/jdphuff.c
+++ b/src/jdphuff.c
@@ -73,6 +73,129 @@ METHODDEF(boolean) decode_mcu_DC_refine(j_decompress_ptr cinfo,
 METHODDEF(boolean) decode_mcu_AC_refine(j_decompress_ptr cinfo,
                                         JBLOCKROW *MCU_data);
 
+#ifdef HUFF_DECODE_OPT
+// OH ISSUE: jpeg optimize
+LOCAL(void)
+jpeg_make_dp_derived_tbl(j_decompress_ptr cinfo, boolean isDC, int tblno,
+                        d_derived_tbl **pdtbl)
+{
+  JHUFF_TBL *htbl;
+  d_derived_tbl *dtbl;
+  int p, i, l, si, numsymbols;
+  int lookbits, ctr;
+  char huffsize[257];
+  unsigned int huffcode[257];
+  unsigned int code;
+
+  /* Note that huffsize[] and huffcode[] are filled in code-length order,
+   * paralleling the order of the symbols themselves in htbl->huffval[].
+   */
+
+  /* Find the input Huffman table */
+  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+  htbl =
+    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
+  if (htbl == NULL)
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+
+  /* Allocate a workspace if we haven't already done so. */
+  if (*pdtbl == NULL)
+    *pdtbl = (d_derived_tbl *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
+                                  sizeof(d_derived_tbl));
+  dtbl = *pdtbl;
+  dtbl->pub = htbl;             /* fill in back link */
+
+  /* Figure C.1: make table of Huffman code length for each symbol */
+
+  p = 0;
+  for (l = 1; l <= MAX_HUFF_CODE_LEN; l++) {
+    i = (int)htbl->bits[l];
+    if (i < 0 || p + i > 256)   /* protect against table overrun, 256 is the max number of symbols */
+      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    while (i--)
+      huffsize[p++] = (char)l;
+  }
+  huffsize[p] = 0;
+  numsymbols = p;
+
+  /* Figure C.2: generate the codes themselves */
+  /* We also validate that the counts represent a legal Huffman code tree. */
+
+  code = 0;
+  si = huffsize[0];
+  p = 0;
+  while (huffsize[p]) {
+    while (((int)huffsize[p]) == si) {
+      huffcode[p++] = code;
+      code++;
+    }
+    /* code is now 1 more than the last code used for codelength si; but
+     * it must still fit in si bits, since no code is allowed to be all ones.
+     */
+    if (((JLONG)code) >= (((JLONG)1) << si))
+      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    code <<= 1;
+    si++;
+  }
+
+  /* Figure F.15: generate decoding tables for bit-sequential decoding */
+
+  p = 0;
+  for (l = 1; l <= MAX_HUFF_CODE_LEN; l++) {
+    if (htbl->bits[l]) {
+      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
+       * minus the minimum code of length l
+       */
+      dtbl->valoffset[l] = (JLONG)p - (JLONG)huffcode[p];
+      p += htbl->bits[l];
+      dtbl->maxcode[l] = huffcode[p - 1]; /* maximum code of length l */
+    } else {
+      dtbl->maxcode[l] = -1;    /* -1 if no codes of this length */
+    }
+  }
+  dtbl->valoffset[17] = 0; /* 17 is always max symbol length in Huffman spec */
+  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates, 17 has the same meaning above */
+
+  /* Compute lookahead tables to speed up decoding.
+   * First we set all the table entries to 0, indicating "too long";
+   * then we iterate through the Huffman codes that are short enough and
+   * fill in all the entries that correspond to bit sequences starting
+   * with that code.
+   */
+
+  for (i = 0; i < (1 << HUFF_LOOKAHEAD); i++)
+    dtbl->lookup[i] = (HUFF_LOOKAHEAD + 1) << HUFF_LOOKAHEAD;
+
+  p = 0;
+  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
+    for (i = 1; i <= (int)htbl->bits[l]; i++, p++) {
+      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
+      /* Generate left-justified code followed by all possible bit sequences */
+      lookbits = huffcode[p] << (HUFF_LOOKAHEAD - l);
+      for (ctr = 1 << (HUFF_LOOKAHEAD - l); ctr > 0; ctr--) {
+        dtbl->lookup[lookbits] = (l << HUFF_LOOKAHEAD) | htbl->huffval[p];
+        lookbits++;
+      }
+    }
+  }
+
+  /* Validate symbols as being reasonable.
+   * For AC tables, we make no check, but accept all byte values 0..255.
+   * For DC tables, we require the symbols to be in range 0..15.
+   * (Tighter bounds could be applied depending on the data depth and mode,
+   * but this is sufficient to ensure safe decoding.)
+   */
+  if (isDC) {
+    for (i = 0; i < numsymbols; i++) {
+      int sym = htbl->huffval[i];
+      if (sym < 0 || sym > 15) // 15 is the max value of DC symbol
+        ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+    }
+  }
+}
+#endif
 
 /*
  * Initialize for a Huffman-compressed scan.
@@ -165,12 +288,22 @@ start_pass_phuff_decoder(j_decompress_ptr cinfo)
       if (cinfo->Ah == 0) {     /* DC refinement needs no table */
         tbl = compptr->dc_tbl_no;
         pdtbl = (d_derived_tbl **)(entropy->derived_tbls) + tbl;
+#ifdef HUFF_DECODE_OPT
+        // OH ISSUE: jpeg optimize
+        jpeg_make_dp_derived_tbl(cinfo, TRUE, tbl, pdtbl);
+#else
         jpeg_make_d_derived_tbl(cinfo, TRUE, tbl, pdtbl);
+#endif
       }
     } else {
       tbl = compptr->ac_tbl_no;
       pdtbl = (d_derived_tbl **)(entropy->derived_tbls) + tbl;
+#ifdef HUFF_DECODE_OPT
+      // OH ISSUE: jpeg optimize
+      jpeg_make_dp_derived_tbl(cinfo, FALSE, tbl, pdtbl);
+#else
       jpeg_make_d_derived_tbl(cinfo, FALSE, tbl, pdtbl);
+#endif
       /* remember the single active table */
       entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
     }
diff --git a/src/jmemsys.h b/src/jmemsys.h
index ac09ef4..ace0965 100644
--- a/src/jmemsys.h
+++ b/src/jmemsys.h
@@ -31,8 +31,8 @@
  * size of the object being freed, just in case it's needed.
  */
 
-EXTERN(void *) jpeg_get_small(j_common_ptr cinfo, size_t sizeofobject);
-EXTERN(void) jpeg_free_small(j_common_ptr cinfo, void *object,
+HIDE(EXTERN)(void *) jpeg_get_small(j_common_ptr cinfo, size_t sizeofobject);
+HIDE(EXTERN)(void) jpeg_free_small(j_common_ptr cinfo, void *object,
                              size_t sizeofobject);
 
 /*
@@ -43,8 +43,8 @@ EXTERN(void) jpeg_free_small(j_common_ptr cinfo, void *object,
  * large chunks.
  */
 
-EXTERN(void *) jpeg_get_large(j_common_ptr cinfo, size_t sizeofobject);
-EXTERN(void) jpeg_free_large(j_common_ptr cinfo, void *object,
+HIDE(EXTERN)(void *) jpeg_get_large(j_common_ptr cinfo, size_t sizeofobject);
+HIDE(EXTERN)(void) jpeg_free_large(j_common_ptr cinfo, void *object,
                              size_t sizeofobject);
 
 /*
@@ -84,7 +84,7 @@ EXTERN(void) jpeg_free_large(j_common_ptr cinfo, void *object,
  * Conversely, zero may be returned to always use the minimum amount of memory.
  */
 
-EXTERN(size_t) jpeg_mem_available(j_common_ptr cinfo, size_t min_bytes_needed,
+HIDE(EXTERN)(size_t) jpeg_mem_available(j_common_ptr cinfo, size_t min_bytes_needed,
                                   size_t max_bytes_needed,
                                   size_t already_allocated);
 
@@ -126,7 +126,7 @@ typedef struct backing_store_struct {
  * just take an error exit.)
  */
 
-EXTERN(void) jpeg_open_backing_store(j_common_ptr cinfo,
+HIDE(EXTERN)(void) jpeg_open_backing_store(j_common_ptr cinfo,
                                      backing_store_ptr info,
                                      long total_bytes_needed);
 
@@ -143,5 +143,5 @@ EXTERN(void) jpeg_open_backing_store(j_common_ptr cinfo,
  * all opened backing-store objects have been closed.
  */
 
-EXTERN(long) jpeg_mem_init(j_common_ptr cinfo);
-EXTERN(void) jpeg_mem_term(j_common_ptr cinfo);
+HIDE(EXTERN)(long) jpeg_mem_init(j_common_ptr cinfo);
+HIDE(EXTERN)(void) jpeg_mem_term(j_common_ptr cinfo);
diff --git a/src/jmorecfg.h b/src/jmorecfg.h
index 6864c06..18402fa 100644
--- a/src/jmorecfg.h
+++ b/src/jmorecfg.h
@@ -174,7 +174,12 @@ typedef unsigned int JDIMENSION;
 #define GLOBAL(type)            type
 /* a reference to a GLOBAL function: */
 #define EXTERN(type)            extern type
-
+/* a function used only in this lib: */
+#ifdef HIDE_INTERNAL
+  #define HIDE(type)            __attribute__((visibility("hidden"))) type
+#else
+  #define HIDE(type)            type
+#endif
 
 /* Originally, this macro was used as a way of defining function prototypes
  * for both modern compilers as well as older compilers that did not support
diff --git a/src/jsimddct.h b/src/jsimddct.h
index 55ee8cf..c19fe41 100644
--- a/src/jsimddct.h
+++ b/src/jsimddct.h
@@ -9,62 +9,62 @@
  *
  */
 
-EXTERN(int) jsimd_can_convsamp(void);
-EXTERN(int) jsimd_can_convsamp_float(void);
+HIDE(EXTERN)(int) jsimd_can_convsamp(void);
+HIDE(EXTERN)(int) jsimd_can_convsamp_float(void);
 
-EXTERN(void) jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,
+HIDE(EXTERN)(void) jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,
                             DCTELEM *workspace);
-EXTERN(void) jsimd_convsamp_float(JSAMPARRAY sample_data, JDIMENSION start_col,
+HIDE(EXTERN)(void) jsimd_convsamp_float(JSAMPARRAY sample_data, JDIMENSION start_col,
                                   FAST_FLOAT *workspace);
 
-EXTERN(int) jsimd_can_fdct_islow(void);
-EXTERN(int) jsimd_can_fdct_ifast(void);
-EXTERN(int) jsimd_can_fdct_float(void);
+HIDE(EXTERN)(int) jsimd_can_fdct_islow(void);
+HIDE(EXTERN)(int) jsimd_can_fdct_ifast(void);
+HIDE(EXTERN)(int) jsimd_can_fdct_float(void);
 
-EXTERN(void) jsimd_fdct_islow(DCTELEM *data);
-EXTERN(void) jsimd_fdct_ifast(DCTELEM *data);
-EXTERN(void) jsimd_fdct_float(FAST_FLOAT *data);
+HIDE(EXTERN)(void) jsimd_fdct_islow(DCTELEM *data);
+HIDE(EXTERN)(void) jsimd_fdct_ifast(DCTELEM *data);
+HIDE(EXTERN)(void) jsimd_fdct_float(FAST_FLOAT *data);
 
-EXTERN(int) jsimd_can_quantize(void);
-EXTERN(int) jsimd_can_quantize_float(void);
+HIDE(EXTERN)(int) jsimd_can_quantize(void);
+HIDE(EXTERN)(int) jsimd_can_quantize_float(void);
 
-EXTERN(void) jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors,
+HIDE(EXTERN)(void) jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors,
                             DCTELEM *workspace);
-EXTERN(void) jsimd_quantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,
+HIDE(EXTERN)(void) jsimd_quantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,
                                   FAST_FLOAT *workspace);
 
-EXTERN(int) jsimd_can_idct_2x2(void);
-EXTERN(int) jsimd_can_idct_4x4(void);
-EXTERN(int) jsimd_can_idct_6x6(void);
-EXTERN(int) jsimd_can_idct_12x12(void);
+HIDE(EXTERN)(int) jsimd_can_idct_2x2(void);
+HIDE(EXTERN)(int) jsimd_can_idct_4x4(void);
+HIDE(EXTERN)(int) jsimd_can_idct_6x6(void);
+HIDE(EXTERN)(int) jsimd_can_idct_12x12(void);
 
-EXTERN(void) jsimd_idct_2x2(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_2x2(j_decompress_ptr cinfo,
                             jpeg_component_info *compptr, JCOEFPTR coef_block,
                             JSAMPARRAY output_buf, JDIMENSION output_col);
-EXTERN(void) jsimd_idct_4x4(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_4x4(j_decompress_ptr cinfo,
                             jpeg_component_info *compptr, JCOEFPTR coef_block,
                             JSAMPARRAY output_buf, JDIMENSION output_col);
-EXTERN(void) jsimd_idct_6x6(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_6x6(j_decompress_ptr cinfo,
                             jpeg_component_info *compptr, JCOEFPTR coef_block,
                             JSAMPARRAY output_buf, JDIMENSION output_col);
-EXTERN(void) jsimd_idct_12x12(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_12x12(j_decompress_ptr cinfo,
                               jpeg_component_info *compptr,
                               JCOEFPTR coef_block, JSAMPARRAY output_buf,
                               JDIMENSION output_col);
 
-EXTERN(int) jsimd_can_idct_islow(void);
-EXTERN(int) jsimd_can_idct_ifast(void);
-EXTERN(int) jsimd_can_idct_float(void);
+HIDE(EXTERN)(int) jsimd_can_idct_islow(void);
+HIDE(EXTERN)(int) jsimd_can_idct_ifast(void);
+HIDE(EXTERN)(int) jsimd_can_idct_float(void);
 
-EXTERN(void) jsimd_idct_islow(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_islow(j_decompress_ptr cinfo,
                               jpeg_component_info *compptr,
                               JCOEFPTR coef_block, JSAMPARRAY output_buf,
                               JDIMENSION output_col);
-EXTERN(void) jsimd_idct_ifast(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_ifast(j_decompress_ptr cinfo,
                               jpeg_component_info *compptr,
                               JCOEFPTR coef_block, JSAMPARRAY output_buf,
                               JDIMENSION output_col);
-EXTERN(void) jsimd_idct_float(j_decompress_ptr cinfo,
+HIDE(EXTERN)(void) jsimd_idct_float(j_decompress_ptr cinfo,
                               jpeg_component_info *compptr,
                               JCOEFPTR coef_block, JSAMPARRAY output_buf,
                               JDIMENSION output_col);
diff --git a/src/jutils.c b/src/jutils.c
index 24caac1..f761189 100644
--- a/src/jutils.c
+++ b/src/jutils.c
@@ -56,6 +56,27 @@ const int jpeg_zigzag_order[DCTSIZE2] = {
  * fake entries.
  */
 
+#ifdef HUFF_DECODE_OPT
+// OH ISSUE: jpeg optimize
+const int jpeg_natural_order[DCTSIZE2 + 64] = {
+  0,  1,  8, 16,  9,  2,  3, 10,
+ 17, 24, 32, 25, 18, 11,  4,  5,
+ 12, 19, 26, 33, 40, 48, 41, 34,
+ 27, 20, 13,  6,  7, 14, 21, 28,
+ 35, 42, 49, 56, 57, 50, 43, 36,
+ 29, 22, 15, 23, 30, 37, 44, 51,
+ 58, 59, 52, 45, 38, 31, 39, 46,
+ 53, 60, 61, 54, 47, 55, 62, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63
+};
+#else
 const int jpeg_natural_order[DCTSIZE2 + 16] = {
   0,  1,  8, 16,  9,  2,  3, 10,
  17, 24, 32, 25, 18, 11,  4,  5,
@@ -68,6 +89,7 @@ const int jpeg_natural_order[DCTSIZE2 + 16] = {
  63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
  63, 63, 63, 63, 63, 63, 63, 63
 };
+#endif
 
 
 /*
